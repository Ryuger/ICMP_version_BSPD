<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>icmpmon</title>
  <style>
    body { font-family: system-ui; margin: 16px; }
    .tabs { display: flex; gap: 6px; flex-wrap: wrap; margin-bottom: 12px; }
    .tab { padding: 6px 10px; border: 1px solid #bbb; border-radius: 8px; cursor: pointer; background: #fff; }
    .tab.active { background: #1f6feb; color: #fff; border-color: #1f6feb; }
    .card { border: 1px solid #ddd; padding: 10px; border-radius: 10px; margin-bottom: 12px; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border-bottom: 1px solid #ddd; padding: 6px; font-size: 13px; }
    .subhead { background: #f7f7f7; font-weight: 600; }
    .up { color: green; }
    .down { color: #b00020; }
    .unk { color: #666; }
    .act { display: flex; gap: 6px; align-items: center; }
    input, select, button { font-size: 12px; }
  </style>
</head>
<body>
  <h2>icmpmon</h2>
  <div id="meta"></div>
  <div id="tabs" class="tabs"></div>

  <div class="card">
    <h3>Add host</h3>
    <form id="addf">
      Group <input name="group" value="Default">
      Subgroup <input name="subgroup" value="Main">
      Host/IP <input name="name" required>
      Interval (ms) <input name="interval_ms" type="number" value="1000" min="50">
      Timeout (ms) <input name="timeout_ms" type="number" value="1000" min="50">
      DownThr (fails) <input name="down_threshold" type="number" value="3" min="1">
      Enabled
      <select name="enabled">
        <option value="1" selected>on</option>
        <option value="0">off</option>
      </select>
      <button>Add</button>
    </form>
    <div id="addmsg"></div>
  </div>

  <div class="card">
    <h3>Excel (CSV)</h3>
    <button type="button" onclick="location.href='/app/api/icmp/export.csv'">Export CSV</button>
    <input id="f" type="file" accept=".csv">
    <button type="button" onclick="previewCsv()">Details</button>
    <button type="button" onclick="importCsv()">Import CSV</button>
    <span id="impmsg"></span>
    <pre id="impdetail" style="white-space: pre-wrap; max-height: 220px; overflow: auto; background: #f8f8f8; padding: 8px"></pre>
  </div>

  <table>
    <thead>
      <tr>
        <th>ID</th><th>Group</th><th>Subgroup</th><th>Host/IP</th><th>Status</th>
        <th>Interval (ms)</th><th>Timeout (ms)</th><th>DownThr (fails)</th><th>Loss</th><th>Details</th>
      </tr>
    </thead>
    <tbody id="tb"></tbody>
  </table>

  <script>
    let selectedGroup = "";
    let loadInFlight = false;
    const csrfToken = "{{.CSRFToken}}";

    function enc(f) { return new URLSearchParams(new FormData(f)).toString(); }

    function drawTabs(list) {
      const groups = [...new Set(list.map(x => x.group || "Default"))].sort();
      if (!selectedGroup && groups.length) selectedGroup = groups[0];
      const tabs = document.getElementById("tabs");
      tabs.innerHTML = "";
      for (const g of groups) {
        const b = document.createElement("button");
        b.className = "tab" + (g === selectedGroup ? " active" : "");
        b.textContent = g;
        b.onclick = () => { selectedGroup = g; render(window._last || { list: [] }); };
        tabs.appendChild(b);
      }
    }

    function render(j) {
      window._last = j;
      document.getElementById("meta").textContent = `hosts=${j.hosts || 0} up=${j.up || 0} down=${j.down || 0} unk=${j.unk || 0}`;
      drawTabs(j.list || []);

      const tb = document.getElementById("tb");
      tb.innerHTML = "";
      const arr = (j.list || []).filter(h => (h.group || "Default") === selectedGroup);
      arr.sort((a, b) => (a.subgroup || "").localeCompare(b.subgroup || "") || a.id - b.id);
      let cur = "";

      for (const h of arr) {
        if (h.subgroup !== cur) {
          cur = h.subgroup;
          const sh = document.createElement("tr");
          sh.className = "subhead";
          sh.innerHTML = `<td colspan="10">${selectedGroup} / ${cur || "Main"}</td>`;
          tb.appendChild(sh);
        }

        const cls = h.st === "UP" ? "up" : (h.st === "DOWN" ? "down" : "unk");
        const hostCell = (h.ip && h.name && h.ip !== h.name) ? `${h.name}<br><small>${h.ip}</small>` : (h.name || h.ip || "");

        const tr = document.createElement("tr");
        tr.innerHTML = `<td>${h.id}</td><td>${h.group}</td><td>${h.subgroup}</td><td>${hostCell}</td><td class="${cls}">${h.st}</td><td>${h.interval_ms}</td><td>${h.timeout_ms}</td><td>${h.down_threshold}</td><td>${h.fail || 0}</td><td><span class="act"><button type="button" onclick="openHost(${h.id})">Open</button><button type="button" onclick="deleteHost(${h.id})">Delete</button></span></td>`;
        tb.appendChild(tr);
      }
    }

    function openHost(id) {
      location.href = "/app/host?id=" + id;
    }

    async function go(force = false) {
      if (loadInFlight && !force) return;
      loadInFlight = true;
      try {
        const r = await fetch("/app/api/icmp/hosts", { cache: "no-store" });
        if (!r.ok) {
          document.getElementById("meta").textContent = `load failed: ${r.status}`;
          return;
        }
        const j = await r.json();
        render(j);
      } catch (e) {
        document.getElementById("meta").textContent = "load failed";
      } finally {
        loadInFlight = false;
      }
    }

    async function addHost(ev) {
      ev.preventDefault();
      const r = await fetch("/app/api/icmp/host/add", {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          "X-CSRF-Token": csrfToken
        },
        body: enc(ev.target)
      });
      document.getElementById("addmsg").textContent = await r.text();
      go(true);
    }

    async function deleteHost(id) {
      const h = (window._last && window._last.list || []).find(x => x.id === id);
      const q = `${h && h.group || ""}, ${h && h.subgroup || ""}, ${h && (h.ip || h.name) || ""}? delete or cancel`;
      if (!confirm(q)) return;
      const r = await fetch("/app/api/icmp/host/delete?id=" + id, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          "X-CSRF-Token": csrfToken
        },
        body: ""
      });
      document.getElementById("addmsg").textContent = await r.text();
      go(true);
    }

    async function previewCsv() {
      const f = document.getElementById("f").files[0];
      if (!f) {
        document.getElementById("impmsg").textContent = "select .csv file first";
        return;
      }
      const txt = await f.text();
      const r = await fetch("/app/api/icmp/import/preview.csv", {
        method: "POST",
        headers: {
          "Content-Type": "text/csv",
          "X-CSRF-Token": csrfToken
        },
        body: txt
      });
      if (!r.ok) {
        document.getElementById("impmsg").textContent = `preview failed: ${r.status}`;
        document.getElementById("impdetail").textContent = "";
        return;
      }
      const j = await r.json();
      document.getElementById("impmsg").textContent = `can_import=${j.preview_can_import} updated=${j.updated || 0} bad=${j.bad} dup_existing=${j.duplicates_existing} dup_file=${j.duplicates_file}`;
      const lines = (j.details || []).map(d => `line ${d.line}: ${d.host || "(empty)"} -> ${d.reason}`);
      document.getElementById("impdetail").textContent = lines.length ? lines.join("\n") : "No conflicts";
    }

    async function importCsv() {
      const f = document.getElementById("f").files[0];
      if (!f) {
        document.getElementById("impmsg").textContent = "select .csv file first";
        return;
      }
      const txt = await f.text();
      const r = await fetch("/app/api/icmp/import.csv", {
        method: "POST",
        headers: {
          "Content-Type": "text/csv",
          "X-CSRF-Token": csrfToken
        },
        body: txt
      });
      if (!r.ok) {
        document.getElementById("impmsg").textContent = `import failed: ${r.status}`;
        document.getElementById("impdetail").textContent = "";
        return;
      }
      const j = await r.json();
      document.getElementById("impmsg").textContent = `imported=${j.imported || 0} updated=${j.updated || 0} bad=${j.bad || 0} dup_existing=${j.duplicates_existing || 0} dup_file=${j.duplicates_file || 0}`;
      const lines = (j.details || []).map(d => `line ${d.line}: ${d.host || "(empty)"} -> ${d.reason}`);
      document.getElementById("impdetail").textContent = lines.length ? lines.join("\n") : "No conflicts";
      go(true);
    }

    document.getElementById("addf").onsubmit = addHost;
    go(true);
    setInterval(() => go(false), 1500);
  </script>
</body>
</html>
